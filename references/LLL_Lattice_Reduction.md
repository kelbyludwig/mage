# LLL Lattice Reduction

## 0. Assumed / Required Background

## 1. High-Level and Quick Motivational Example.

TODO(kkl): Use GGH Post Here.

## 2. Two Dimensional Reduction

To get a sense of LLL it helps to consider the two-dimensional case. Suppose
we have the following kinda crappy basis.

```
sage: b1 = vector(ZZ, [30,40])
sage: b2 = vector(ZZ, [40,50])
sage: from mage import matrix_utils # https://github.com/kelbyludwig/mage
sage: matrix_utils.plot_2d_lattice(b1, b2, xmin=-60, xmax=60, ymin=-60, ymax=60)
```

Why is it crappy? Well, for one, the vectors are pretty long. They are also not
orthogonal, which would be ideal (see my GGH post above for more intuitive
details). Just from a visual inspection, there are clearly "better" bases for
this lattice!

A good first step in improving this hunk-o-junk basis is applying
[Gram-Schmidt](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process).
Gram-Schmidt (GS) will take a basis for a vector space (like our lattice!) and transform
the basis vectors into a set of (optionally normalized) orthogonal vectors. 
GS gets us closer to the basis we want, but GS is not guaranteed to produce
orthogonal vectors that form a basis for our lattice. Check it:

```
sage: b1 = vector(ZZ, [3,7])
sage: b2 = vector(ZZ, [4,11])
sage: B = Matrix(ZZ, [b1,b2])
sage: Br,_ = B.gram_schmidt()
sage: matrix_utils.plot_2d_lattice(Br[0],Br[1]) + plot(B[0], color='red') + plot(B[1], color='red')
```

Note that the basis formed by the blue vectors is quite different than the
lattice that would be generated by the original red vectors. We can, however,
modify the internals of GS to produce vectors that _are_ in the original basis.
Instead of *just* taking the projection of each vector onto each other, we
can round the scalar produced during the projection and use a guaranteed
integer scalar. Before, GS used vector projection code that would
look something like this:

```
def proj(u, v):
    zv = zero_vector(len(u))
    if u == zv:
        return zv
    return ((v*u) / (u*u)) * u
```

Now, we can just modify the return statement to return:

```
def proj_round(u, v):
    zv = zero_vector(len(u))
    if u == zv:
        return zv
    return round((v*u) / (u*u)) * u
```

TODO(kkl): Show that the "new" "GS" is for sure produces lattice vectors because linear combs.

TODO(kkl): proj_round intuitively: u may be of the form u = u' + x*v. in other words, u can be
compromised of some (shorter) vector u' and some multiple of v.
